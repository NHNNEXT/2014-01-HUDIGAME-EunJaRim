
* 게임 콘텐츠 코드가 많아 지면서,
기존의 기반 코드(네트워크 전송 등)와 하나의 클래스 내에서 마구 섞이게 됨.. 
이런 시점에서 보통 콘텐츠 코드를 분리함.

ClientSession이 말 그대로 기반 코드 계층이면, Player 라는 클래스가 콘텐츠 전용 계층의 코드.
보통 이 경우, ClientSession이 Player를 포인터로 들고 있는 형태가 됨

* 꼼수를 하나 알려주마.

꼽스가 룸의 포인터를 항상 들고 있는데... 이러지 말고,
꼽스의 id나 플레이어의 id 일부분을 룸의 번호를 포함하게 할 수 있음.

32비트 int의 경우에.. 비트 연산으로 상위 8비트를 룸 번호로 집어 넣고 하위 24비트를 순차번호로 사용.

즉, [RRRRRRRR | IIIIIIII | IIIIIIII | IIIIIIII] 이렇게 구성.
이렇게 되면 룸은 최대 256개까지만 지원하겠지.. 고유 id는 16777216개까지.

그러면 자신의 id >> 24 하면, 바로 룸 번호가 나옴. 
룸번호 -> 룸 포인터 맵핑 테이블 하나 가지고 있으면 아래와 같은 함수 하나 만들어서 사용 가능

GameRoom* Corps::GetMyRoom()
{
   return RoomArray[mCopyId>>24]
}



* 나머지는

///# 검색 ㄱㄱ